## 泛型数据类型

### 在函数定义中使用泛型
当使用泛型定义函数时，本来在函数签名中指定参数和返回值的类型的地方，会改用泛型来表示。采用这种技术，使得代码适应性更强，从而为函数的调用者提供更多的功能，同时也避免了代码的重复。

```rust
fn largest<T>(list: &[T]) -> T {}
```

这个函数可以这么理解：函数 largest 有泛型类型 T。他有个参数 list，其类型是元素为 T 的 slice。largest 函数返回值类型也是 T。

### 结构体定义中的泛型
同样也可以用 <> 语法类定义结构体，它包含一个或多个泛型参数类型字段。
```rust
struct Point<T> {
  x: T,
  y: T,
}
fn main () {
  let integer = Point { x: 5, y: 3 };
  let float = Point { x: 2.0, y: 2.1 };
}
```
语法类似于函数定义中使用泛型。首先，必须在结构体名称后面的尖括号中声明泛型参数的名称。接着在结构体定义中可以制定具体数据类型的位置使用泛型类型。

如果想要定义一个 x 和 y 可以有不同类型且任然是泛型的 Point 机构提，我们可以使用多个泛型类型参数。

```rust
struct Point<T, U> {
  x: T,
  y: U
}

fn main () {
  let one = Point({ x: 5, y: 4.5 })
}
```

### 枚举定义中的泛型

和结构体类似，枚举也可以在成员中存放泛型数据类型。

```rust
enum Option<T> {
  Some<T>,
  None,
}

enum Result<T, E> {
  Ok(T),
  Err(E)
}
```

### 方法定义中的泛型

```rust
struct Point<T> {
  x: T,
  y: T,
}

impl<T> Point<T> {
  fn x(&self) -> &T {
    &self.x
  }
}

fn main() {
  let p = Point { x: 5, y: 10 };
  println!("p.x = {}", p.x());
}
```

注意必须在 impl 后面声明 T，这样就可以在 Point<T> 上实现的方法中使用它了。在 impl 之后声明泛型 T，这样 Rust 就知道 Point 的尖括号中的类型是泛型而不是具体类型。

### 泛型代码的性能
Rust 实现了泛型，使得使用泛型类型参数的代码相比使用具体类型并没有任何速度上的损失。

Rust 通过在编译时进行泛型代码的单态化来保证效率。单态化是一个通过填充编译时使用的具体类型，将通用代码转换为特定代码的过程。