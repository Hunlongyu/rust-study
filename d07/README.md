## 所有权

### 什么是所有权

#### 了解 栈（Stack）与堆（Heap）
1. 栈和堆都是代码在运行时可供使用的内存，但是他们的结构不同。
2. 栈以放入值的顺序存储并以相反的顺序取出值。即后进先出（last in， first out）。
3. 增加数据叫做`进栈（pushing onto the stack）`
4. 移出数据叫做`出栈（phpping off the stack）`
5. 栈中的所有数据都必须占用已知且固定的大小。
6. 在编译时大小未知或大小可能变化的数据，要改为存储在堆上（Heap）。
7. 堆是缺乏组织的：当向堆放入数据时，要请求一定大小的空间。
8. 内存分配器（memory allocator）在堆的某处找到一块足够大的空位，标记已使用，并返回该位置地址的`指针（pointer）`.
9. 在堆上分配内存（allocating on the heap），简称：`分配（allocating）`
10. 入栈比在堆上分配内存要快，因为入栈时分配器无需为存储新数据去搜索内存空间
11. 在堆上分配内存需要找到足够存放数据的内存空间，并接着做一些记录为下一次分配做准备
12. 访问堆上的数据比访问栈上的数据慢，因为必须通过指针来访问。
13. 现代处理器在内存中跳转越少就越快

#### 了解所有权规则
1. Rust 中的每一个值都有一个被称为其`所有者（owner）`的变量
2. 值在任一时刻有且只有一个所有者
3. 当所有者（变量）离开作用域，这个值将被丢弃。

#### 内存与分配
1. 在有`垃圾回收（garbage collector，GC）` 的语言中，GC记录并清除不再使用的内存
2. 没有 GC 的的话，需要识别出不再使用的内存并调用代码显式释放
3. 在 rust 语言中，内存在拥有它的变量离开作用域后就被自动释放
4. 浅拷贝（shallow copy）和深拷贝（deep copy）
5. rust 没有浅拷贝概念，移动
6. rust 中深拷贝（clone）
7. rust 中 copy 类型: 
    * 所有整数类型
    * 布尔类型
    * 所有浮点数类型，如：f64
    * 字符类型，char
    * 元组，当且仅当其包含的类型也都实现 copy 的时候

### 引用和借用
1. `&` 符号就是`引用`，他们允许使用值但不获取其所有权
2. 创建一个引用的行为称为`借用（borrowing）` 

#### 可变引用
1. 可变引用限制：在同一时间只能有一个对某一特定数据的可变引用
2. 这个限制的好处是 rust 可以在编译时就避免数据竞争
3. 数据竞争类似于竞态条件，它可由这三个行为造成：
    * 两个或更多指针同时访问同一数据
    * 至少有一个指针被用来写入数据
    * 没有同步数据访问的机制
4. 数据竞争会导致未定i行为，难以在运行时追踪，并且难以诊断和修复
5. 不能拥有不可变引用的同时拥有可变引用
6. 可以有多个不可变引用

#### 垂悬引用（Dangling References）
1. 在具有指针的语言中，很容易通过释放内存时保留指向它的指针而错误的生成一个`垂悬指针（dangling pointer）`
2. 在 rust 中，当你拥有一些数据的引用，编译器确保数据不会在引用之前离开作用域。

#### 应用规则
1. 在任意给定时间，要么只能有一个可变引用，要么只能由多个不可变引用
2. 引用必须总是有效的
